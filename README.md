<h1 align="center">
      AlgoritmosDeOrdenamento </a>
</h1>

<h4 align="center">
	üöß    Em constru√ß√£o...   üöß
</h4>

Tabela de conte√∫dos
=================
<!--ts-->
   * [Sobre o projeto](#-sobre-o-projeto)
     * [ShellSort](#shellsort)
     	* [Como funciona](#como-funciona) 
     * [QuickSort](#quicksort)
     * [QuickSort + Insertion Sort](#quicksort--insertion-sort)
     * [Radix Sort](#radix-sort)
     	* [Efici√™ncia](#efici√™ncia)
   * [Funcionalidades](#gear-funcionalidades)
   * [Testes](#clipboard-testes)
   * [Complexidade](#chart_with_upwards_trend-complexidade)

<!--te-->

## üíª Sobre o projeto

Este programa tem como objetivo analisar v√°rios algoritmos de ordenamento, exportando para excel os tempos de execu√ß√£o para v√°rios valores de estudo 

---


## QuickSort + Insertion Sort

## Radix Sort

Na ci√™ncia da computa√ß√£o, ** radix sort ** √© uma classifica√ß√£o inteira n√£o comparativa 
algoritmo que classifica os dados com chaves inteiras agrupando chaves por indiv√≠duo 
d√≠gitos que compartilham a mesma posi√ß√£o significativa e valor. Uma nota√ß√£o posicional
√© obrigat√≥rio, mas porque os inteiros podem representar cadeias de caracteres 
(por exemplo, nomes ou datas) e n√∫meros de ponto flutuante especialmente formatados, raiz 
sort n√£o se limita a inteiros.


### Efici√™ncia

O t√≥pico da efici√™ncia da classifica√ß√£o raiz em compara√ß√£o com outros algoritmos de classifica√ß√£o √© 
um tanto complicado e sujeito a muitos mal-entendidos. Se radix
sort √© igualmente eficiente, menos eficiente ou mais eficiente do que o melhor 
algoritmos baseados em compara√ß√£o dependem dos detalhes das suposi√ß√µes feitas. 
A complexidade da ordena√ß√£o de raiz √© `O (wn)` para chaves `n` que s√£o inteiros de tamanho de palavra` w`. 
√Äs vezes, `w` √© apresentado como uma constante, o que tornaria a ordena√ß√£o radix melhor 
(para `n` suficientemente grande) do que os melhores algoritmos de classifica√ß√£o baseados em compara√ß√£o, 
em que todos realizam compara√ß√µes `O (n log n)` para classificar as chaves `n`. No entanto, em
geral `w` n√£o pode ser considerado uma constante: se todas as chaves` n` s√£o distintas, 
ent√£o `w` tem que ser pelo menos` log n` para uma m√°quina de acesso aleat√≥rio ser capaz de 
armazene-os na mem√≥ria, o que d√°, na melhor das hip√≥teses, uma complexidade de tempo `O (n log n)`. Este
pareceria tornar a classifica√ß√£o radix no m√°ximo igualmente eficiente quanto a melhor 
classifica√ß√µes baseadas em compara√ß√£o (e pior se as chaves forem muito mais longas do que `log n`).

![Radix Sort](https://www.researchgate.net/publication/291086231/figure/fig1/AS:614214452404240@1523451545568/Simplistic-illustration-of-the-steps-performed-in-a-radix-sort-In-this-example-the.png)




---

## :gear: Funcionalidades

- [x] Criar v√°rios tipos de arrays num√©ricos
- [x] Ordenar arrays num√©ricos
- [x] Exportar dados para excel

## :clipboard: Testes

Para os testes realizados usaram-se arrays de 500.000 at√© 10.000.000 elementos, com intervalos de 500.000.\
Os arrays podiam estar desordenados, ordenados decrescentemete, 99% ordenados e 95% ordenados.

## :chart_with_upwards_trend: Complexidade

| Nome                  | Melhor          | M√©dia               | Pior                | M√©moria   | Est√°vel   | coment√°rios |
| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :--------   |
| **Insertion sort**    | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Sim       |             |
| **Quick sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n<sup>2</sup>       | log(n)    | N√£o       | O Quicksort geralmente √© feito no local com o espa√ßo de pilha O  O(log(n)) stack space |
| **Shell sort**        | n&nbsp;log(n)   | depende da sequ√™ncia de lacunas | n&nbsp;(log(n))<sup>2</sup>     | 1      | N√£o    |                   |
| **Radix sort**        | n * k           | n * k               | n * k               | n + k     | Sim       | k - comprimento da chave mais longa |
