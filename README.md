<h1 align="center">
      AlgoritmosDeOrdenamento </a>
</h1>

<h4 align="center">
	üöß    Em constru√ß√£o...   üöß
</h4>

Tabela de conte√∫dos
=================
<!--ts-->
   * [Sobre o projeto](#-sobre-o-projeto)
     * [ShellSort](#shellsort)
     	* [Como funciona](#como-funciona) 
     * [QuickSort](#quicksort)
     * [QuickSort + Insertion Sort](#quicksort--insertion-sort)
     * [Radix Sort](#radix-sort)
     	* [Efici√™ncia](#efici√™ncia)
   * [Funcionalidades](#gear-funcionalidades)
   * [Testes](#clipboard-testes)
   * [Complexidade](#chart_with_upwards_trend-complexidade)

<!--te-->

## üíª Sobre o projeto

Este programa tem como objetivo analisar v√°rios algoritmos de ordenamento, exportando para excel os tempos de execu√ß√£o para v√°rios valores de estudo 

---
## ShellSort

Shellsort √© um tipo de compara√ß√£o no local. Pode ser visto como uma generaliza√ß√£o do Bubble Sort ou Insertion Sort.\
O m√©todo come√ßa classificando pares de elementos distantes um do outro, ent√£o progressivamente reduz a lacuna entre os elementos a serem comparados.\
Inicia com elementos distantes, pode mover alguns elementos fora do lugar 
elementos na posi√ß√£o mais r√°pido do que um vizinho mais pr√≥ximo simples 
interc√¢mbio.

![Shellsort](https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif)
## Como funciona
Para nosso exemplo e facilidade de compreens√£o, usamos o intervalo de `4`. Fa√ßa uma sub-lista virtual de todos os valores localizados no intervalo de 4 posi√ß√µes. Aqui estes valores s√£o `{35, 14}`, `{33, 19}`, `{42, 27}` e `{10, 44}`

![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort_gap_4.jpg)

Comparamos os valores em cada sub-lista e os trocamos (se necess√°rio) na matriz original. Ap√≥s esta etapa, a nova matriz deve ser semelhante a esta

![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort_step_1.jpg)

Ent√£o, pegamos o intervalo de 2 e esta lacuna gera duas sublistas

- `{14, 27, 35, 42}`, `{19, 10, 33, 44}`

![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort_gap_2.jpg)

Comparamos e trocamos os valores, se necess√°rio, na matriz original. Ap√≥s esta etapa, a matriz deve ficar assim

![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort_step_2.jpg)

> UPD: na imagem abaixo h√° um erro de digita√ß√£o e a matriz de resultados deve estar  `[14, 10, 27, 19, 35, 33, 42, 44]`.

Por fim, classificamos o restante do array usando o intervalo de valor 1. A classifica√ß√£o por shell usa a classifica√ß√£o por inser√ß√£o para classificar o array.

![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort.jpg)

## QuickSort

Quicksort √© um algoritmo de divis√£o e conquista.
Quicksort primeiro divide uma grande matriz em duas menores 
submatrizes: os elementos baixos e os elementos altos.
O Quicksort pode ent√£o classificar recursivamente as submatrizes

As etapas s√£o:

1. Escolha um elemento, denominado piv√¥, da matriz.
2. Particionamento: reordene a matriz para que todos os elementos com 
valores menores que o piv√¥ v√™m antes do piv√¥, enquanto todos 
elementos com valores maiores do que o piv√¥ v√™m depois dele 
(valores iguais podem ser usados em qualquer dire√ß√£o). Ap√≥s este particionamento,
o piv√¥ est√° em sua posi√ß√£o final. Isso √© chamado de
opera√ß√£o de parti√ß√£o.
3. Aplique recursivamente as etapas acima √† submatriz de 
elementos com valores menores e separadamente para o 
submatriz de elementos com valores maiores.

Visualiza√ß√£o animada do algoritmo quicksort.

![Quicksort](https://www.tutorialspoint.com/data_structures_algorithms/images/quick_sort_partition_animation.gif)


## QuickSort + Insertion Sort

## Radix Sort

Na ci√™ncia da computa√ß√£o, ** radix sort ** √© uma classifica√ß√£o inteira n√£o comparativa 
algoritmo que classifica os dados com chaves inteiras agrupando chaves por indiv√≠duo 
d√≠gitos que compartilham a mesma posi√ß√£o significativa e valor. Uma nota√ß√£o posicional
√© obrigat√≥rio, mas porque os inteiros podem representar cadeias de caracteres 
(por exemplo, nomes ou datas) e n√∫meros de ponto flutuante especialmente formatados, raiz 
sort n√£o se limita a inteiros.


### Efici√™ncia

O t√≥pico da efici√™ncia da classifica√ß√£o raiz em compara√ß√£o com outros algoritmos de classifica√ß√£o √© 
um tanto complicado e sujeito a muitos mal-entendidos. Se radix
sort √© igualmente eficiente, menos eficiente ou mais eficiente do que o melhor 
algoritmos baseados em compara√ß√£o dependem dos detalhes das suposi√ß√µes feitas. 
A complexidade da ordena√ß√£o de raiz √© `O (wn)` para chaves `n` que s√£o inteiros de tamanho de palavra` w`. 
√Äs vezes, `w` √© apresentado como uma constante, o que tornaria a ordena√ß√£o radix melhor 
(para `n` suficientemente grande) do que os melhores algoritmos de classifica√ß√£o baseados em compara√ß√£o, 
em que todos realizam compara√ß√µes `O (n log n)` para classificar as chaves `n`. No entanto, em
geral `w` n√£o pode ser considerado uma constante: se todas as chaves` n` s√£o distintas, 
ent√£o `w` tem que ser pelo menos` log n` para uma m√°quina de acesso aleat√≥rio ser capaz de 
armazene-os na mem√≥ria, o que d√°, na melhor das hip√≥teses, uma complexidade de tempo `O (n log n)`. Este
pareceria tornar a classifica√ß√£o radix no m√°ximo igualmente eficiente quanto a melhor 
classifica√ß√µes baseadas em compara√ß√£o (e pior se as chaves forem muito mais longas do que `log n`).

![Radix Sort](https://www.researchgate.net/publication/291086231/figure/fig1/AS:614214452404240@1523451545568/Simplistic-illustration-of-the-steps-performed-in-a-radix-sort-In-this-example-the.png)




---

## :gear: Funcionalidades

- [x] Criar v√°rios tipos de arrays num√©ricos
- [x] Ordenar arrays num√©ricos
- [x] Exportar dados para excel

## :clipboard: Testes

Para os testes realizados usaram-se arrays de 500.000 at√© 10.000.000 elementos, com intervalos de 500.000.\
Os arrays podiam estar desordenados, ordenados decrescentemete, 99% ordenados e 95% ordenados.

## :chart_with_upwards_trend: Complexidade

| Nome                  | Melhor          | M√©dia               | Pior                | M√©moria   | Est√°vel   | coment√°rios |
| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :--------   |
| **Insertion sort**    | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Sim       |             |
| **Quick sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n<sup>2</sup>       | log(n)    | N√£o       | O Quicksort geralmente √© feito no local com o espa√ßo de pilha O  O(log(n)) stack space |
| **Shell sort**        | n&nbsp;log(n)   | depende da sequ√™ncia de lacunas | n&nbsp;(log(n))<sup>2</sup>     | 1      | N√£o    |                   |
| **Radix sort**        | n * k           | n * k               | n * k               | n + k     | Sim       | k - comprimento da chave mais longa |
